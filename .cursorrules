# FeedToki - R√®gles de D√©veloppement Cursor

## ‚ö†Ô∏è R√àGLES CRITIQUES - PRIORIT√â ABSOLUE

Ces r√®gles doivent TOUJOURS √™tre respect√©es, sans exception.

### 1. Utilisateurs Existants - R√àGLE CRITIQUE

‚ö†Ô∏è **IL Y A DES UTILISATEURS QUI EXISTENT D√âJ√Ä DANS LA BASE DE DONN√âES**

**Actions requises :**
- TOUJOURS prendre en compte les utilisateurs existants lors de toute modification
- TOUJOURS mettre √† jour les utilisateurs existants aussi, pas seulement les nouveaux
- TOUJOURS v√©rifier la compatibilit√© avec les donn√©es existantes avant de modifier la structure
- TOUJOURS utiliser `set()` avec `merge: true` ou v√©rifier l'existence avant `update()` pour √©viter les erreurs
- TOUJOURS cr√©er des migrations si n√©cessaire pour mettre √† jour les utilisateurs existants
- TOUJOURS tester les migrations sur un utilisateur de test avant de les appliquer √† tous
- TOUJOURS s'assurer que les nouveaux champs ont des valeurs par d√©faut pour les utilisateurs existants
- TOUJOURS documenter les migrations dans `toki-app/MIGRATION_GUIDE.md`

**Pattern √† utiliser pour Firestore :**
```typescript
// ‚úÖ CORRECT - V√©rifier existence avant update
const userRef = admin.firestore().doc(`users/${userId}`);
const userDoc = await userRef.get();
if (!userDoc.exists) {
  // Cr√©er le document avec les champs de base
  await userRef.set({
    userId: userId,
    email: userEmail,
    createdAt: new Date().toISOString(),
    ...newData,
  });
} else {
  // Mettre √† jour le document existant
  await userRef.update(newData);
}

// ‚úÖ ALTERNATIVE - Utiliser set avec merge
await userRef.set({
  ...existingData,
  ...newData,
}, { merge: true });
```

**Exemple de migration :**
Si vous modifiez la structure d'un document Firestore, cr√©er un script de migration dans `toki-app/scripts/` pour mettre √† jour tous les documents existants.

### 2. Fonctionner du Premier Coup - R√àGLE CRITIQUE

‚ö†Ô∏è **QUAND L'UTILISATEUR DEMANDE QUELQUE CHOSE, √áA DOIT FONCTIONNER DU PREMIER COUP LE PLUS POSSIBLE**

**Actions requises :**
- TOUJOURS tester mes modifications avant de les pr√©senter
- TOUJOURS v√©rifier que le code compile sans erreurs
- TOUJOURS v√©rifier les linters et corriger les erreurs
- TOUJOURS penser aux cas limites et aux utilisateurs existants
- TOUJOURS v√©rifier la compatibilit√© avec les donn√©es existantes
- SI JE DOIS FAIRE PLUS DE TESTS, JE DOIS LES FAIRE
- Ne pas h√©siter √† ex√©cuter des commandes pour v√©rifier
- Ne pas h√©siter √† lire des fichiers pour comprendre le contexte
- Ne pas h√©siter √† chercher dans le codebase pour trouver des exemples
- Si je ne suis pas s√ªr, je dois tester ou chercher dans le codebase avant de r√©pondre
- Si quelque chose ne fonctionne pas, je dois investiguer et corriger imm√©diatement

### 3. React Hooks - R√àGLE CRITIQUE

‚ö†Ô∏è **TOUJOURS d√©clarer TOUS les hooks AVANT tout `return` conditionnel**

```typescript
// ‚úÖ CORRECT
export default function Component() {
  const [state, setState] = useState(false);
  const memoized = useMemo(() => computeValue(), []);
  useEffect(() => {
    // Side effects
  }, []);
  
  if (!isClient) return <Loading />; // Apr√®s tous les hooks
  
  return <MainContent />;
}

// ‚ùå INCORRECT - Erreur React #418/#310
export default function Component() {
  if (!isClient) return <Loading />; // AVANT les hooks !
  const [state, setState] = useState(false);
  return <MainContent />;
}
```

**Solution pour erreurs d'hydratation :**
- Utiliser un √©tat `isClient` avec `useState(false)` + `useEffect(() => setIsClient(true), [])`
- Retourner "Chargement..." si `!isClient`, apr√®s TOUS les hooks

### 4. Modals sur Web - R√àGLE CRITIQUE

‚ö†Ô∏è **Sur le web, les Modals avec View overlay transparent peuvent bloquer les √©v√©nements touch**

**Probl√®me :** Les boutons/TouchableOpacity dans un Modal ne r√©pondent pas aux clics sur le web, m√™me si les handlers sont appel√©s.

**Solution :**
1. Ajouter `pointerEvents="box-none"` au View overlay (celui avec backgroundColor transparent)
2. Ajouter un View wrapper avec `pointerEvents="auto"` autour du contenu du modal (Card)
3. Pour navigation apr√®s action : Utiliser `router.replace()` au lieu de `router.push()` pour navigation imm√©diate qui ferme le modal automatiquement

```tsx
// ‚úÖ CORRECT
<Modal visible={visible} transparent animationType="fade">
  <View style={overlayStyle} pointerEvents="box-none">
    <View pointerEvents="auto">
      <Card style={modalStyle}>
        {/* Contenu du modal - boutons, etc. */}
      </Card>
    </View>
  </View>
</Modal>
```

**R√©f√©rence :** `toki-app/components/paywall-modal.tsx` utilise cette structure

### 5. Logs de Diagnostic - R√àGLE CRITIQUE

‚ö†Ô∏è **NE JAMAIS conditionner les logs de diagnostic par `__DEV__` si ils sont n√©cessaires pour le debugging en production**

```typescript
// ‚ùå INCORRECT - Logs invisibles en production
if (__DEV__) {
  console.log('[Sync Repair] üîß R√©paration des items manquants...');
}

// ‚úÖ CORRECT - Logs toujours visibles pour diagnostic
console.log('[Sync Repair] üîß R√©paration des items manquants...');
```

**Raison :** Les logs de diagnostic sont essentiels pour comprendre pourquoi une fonction ne s'ex√©cute pas ou √©choue silencieusement. Si un log est important pour le debugging (m√™me en production), il doit √™tre toujours affich√©.

**Exception :** Seuls les logs de d√©veloppement temporaires (ex: valeurs de variables pour tests) peuvent √™tre conditionn√©s par `__DEV__`.

### 6. Acc√®s Complet et Autonomie

- L'utilisateur me donne acc√®s √† TOUT sur son ordinateur
- Je peux ex√©cuter des commandes, lire/√©crire des fichiers, installer des packages, etc.
- Je dois √™tre **autonome** et **proactif** dans mes actions
- Si j'ai besoin de quelque chose, je dois le faire moi-m√™me plut√¥t que de demander

---

## üìã Vue d'ensemble du Projet

Application React Native (Expo SDK 54) de suivi nutritionnel gamifi√© avec syst√®me de points, Firebase, et IA (OpenAI).

**Stack technique :**
- **Frontend :** React Native avec Expo Router (file-based routing)
- **State :** React hooks (useState, useEffect, useMemo, useCallback) + AsyncStorage + Firestore
- **Auth :** Firebase Authentication (email/password)
- **Database :** Firestore (avec synchronisation bidirectionnelle AsyncStorage ‚Üî Firestore)
- **AI :** OpenAI GPT-4o-mini pour parsing de repas

**Langue :**
- **UI/UX :** Toujours en fran√ßais (messages utilisateur, labels, alertes)
- **Code :** Commentaires en fran√ßais
- **Variables/Fonctions :** camelCase en anglais (convention React Native)

---

## üîß Conventions de Code

### Naming

- **Variables/Fonctions :** `camelCase` (ex: `handleDeleteEntry`, `currentUserId`)
- **Composants :** `PascalCase` (ex: `HomeScreen`, `DragonDisplay`)
- **Fichiers :** `kebab-case.tsx` ou `camelCase.tsx` (ex: `best-days.tsx`, `data-sync.ts`)
- **Types/Interfaces :** `PascalCase` (ex: `MealEntry`, `UserProfile`)
- **Constantes :** `UPPER_SNAKE_CASE` (ex: `MAX_POINTS`, `DAILY_POINTS`)

### Structure de Fichiers

```
toki-app/
‚îú‚îÄ‚îÄ app/                    # Expo Router pages
‚îÇ   ‚îú‚îÄ‚îÄ (tabs)/            # Pages principales (navigation tabs)
‚îÇ   ‚îú‚îÄ‚îÄ auth.tsx           # Login/signup
‚îÇ   ‚îî‚îÄ‚îÄ stats.tsx          # Statistiques
‚îú‚îÄ‚îÄ lib/                   # Logique m√©tier
‚îÇ   ‚îú‚îÄ‚îÄ auth-context.tsx   # Context d'authentification
‚îÇ   ‚îú‚îÄ‚îÄ data-sync.ts       # Sync AsyncStorage ‚Üî Firestore
‚îÇ   ‚îú‚îÄ‚îÄ firebase-*.ts      # Configuration Firebase
‚îÇ   ‚îú‚îÄ‚îÄ stats.ts           # Calculs de streaks/scores
‚îÇ   ‚îú‚îÄ‚îÄ points-*.ts        # Syst√®me de points
‚îÇ   ‚îî‚îÄ‚îÄ logger.ts          # Logging centralis√©
‚îú‚îÄ‚îÄ components/            # Composants r√©utilisables
‚îÇ   ‚îú‚îÄ‚îÄ ui/               # Composants UI de base
‚îÇ   ‚îî‚îÄ‚îÄ *.tsx             # Composants sp√©cifiques
‚îú‚îÄ‚îÄ constants/            # Constantes et configuration
‚îî‚îÄ‚îÄ scripts/              # Scripts utilitaires
```

### Gestion d'√âtat

- **Local state :** `useState` pour donn√©es temporaires/composant
- **AsyncStorage :** Pour donn√©es persistantes locales (backup/cache)
- **Firestore :** Source de v√©rit√© pour donn√©es cloud (multi-appareils)
- **Synchronisation :** Toujours via `toki-app/lib/data-sync.ts` (fusion intelligente)

### Logging

- Utiliser `toki-app/lib/logger.ts` pour logs structur√©s
- En production : `logger.debug()` et `logger.info()` sont mut√©s
- Toujours utiliser `logger.warn()` et `logger.error()` pour probl√®mes importants
- Pour logs temporaires : `console.log` avec `if (__DEV__)`

---

## üìä Patterns et Architecture

### Synchronisation de Donn√©es

**Principe de Fusion :**
- **Points :** Prendre la valeur la plus HAUTE (pour pr√©server remboursements/corrections)
- **Meals :** Fusion par ID (Firestore prioritaire si conflit)
- **Targets/Weights :** Firestore prioritaire si local vide

**Fonctions de Sync :**
- `syncFromFirestore()` : Charger depuis Firestore et fusionner avec local
- `syncToFirestore()` : Envoyer vers Firestore
- Toujours appeler apr√®s modifications critiques (ajout/suppression repas, points)

**R√©f√©rence :** `toki-app/lib/data-sync.ts`

### Points - R√®gles Sp√©ciales

- **Remboursement :** Lors de suppression d'entr√©e, restaurer points ET synchroniser Firestore
- **Fusion :** `Math.max(local, firestore)` pour √©viter perte de remboursements
- **√âcriture :** Ne jamais √©craser une valeur Firestore plus haute

### R√©paration Automatique des Items Manquants

- **Fonction :** `repairMissingItemsInMeals()` dans `toki-app/lib/sync-repair.ts`
- **R√¥le :** D√©tecte les aliments mentionn√©s dans le titre d'un repas mais absents de l'array `items` et les ajoute automatiquement
- **Ex√©cution :** Automatique au chargement des repas dans `toki-app/app/(tabs)/index.tsx`
- **Logs :** Toujours afficher les logs de diagnostic (pas de `__DEV__`) pour tracer l'ex√©cution
- **Exemple :** Si un repas a le titre "P√¢tes, Poulet, Brocoli, sauce blanche" mais que "sauce blanche" n'est pas dans `items`, la fonction l'ajoute automatiquement avec un score de similarit√© ‚â• 0.5

### Data Isolation

Toujours utiliser `currentUserId` correctement :

```typescript
const currentUserId = profile?.userId || (user as any)?.uid || (user as any)?.id || 'guest';
```

Reset state local lors changement d'utilisateur (useEffect avec d√©pendance `currentUserId`)

---

## üé® UI/UX

### Th√®me

- Support dark/light mode via `toki-app/lib/theme-context.tsx`
- Utiliser `useTheme()` hook pour acc√©der aux couleurs
- Tokens de design dans `toki-app/constants/design-tokens.ts`

### Composants

- Utiliser composants UI r√©utilisables : `Button`, `Card`, `ProgressBar`, `Badge`
- Modals : Utiliser React Native `Modal` (pas de View absolute) pour centrage correct

### Messages Utilisateur

- Toujours en fran√ßais
- Messages d'erreur clairs et actionnables
- Pour emails Firebase (spam) : Mentionner explicitement dossier SPAM/COURRIER IND√âSIRABLE

---

## üîê S√©curit√© & Firebase

### Authentification

- V√©rification email requise pour utilisation IA (sauf admins)
- Admins : Liste centralis√©e dans `toki-app/lib/admin-utils.ts`
- Guest mode : Permis mais fonctionnalit√©s limit√©es

### Firestore Security Rules

- Toujours v√©rifier `request.auth.uid` pour isolation des donn√©es
- Users peuvent lire/√©crire uniquement leurs propres donn√©es
- Admins : Acc√®s sp√©cial via `isAdmin()` helper

### Rate Limiting

- OpenAI API : 50 appels/jour par utilisateur (Firestore-based)
- Client-side : 10 req/min avec d√©lai minimum 2s entre appels

---

## üöÄ D√©ploiement

### Mise √† Jour de Version - R√àGLE CRITIQUE

‚ö†Ô∏è **TOUJOURS mettre √† jour la version AVANT de d√©ployer**

**√âtapes :**

1. **Mettre √† jour la version dans 3 fichiers :**
   - `toki-app/package.json` : `"version": "1.0.XX"`
   - `toki-app/app.json` : `"version": "1.0.XX"`
   - `toki-app/lib/build-version.ts` : `BUILD_VERSION = '1.0.XX'` ET `BUILD_DATE = 'YYYY-MM-DDTHH:mm:ss.000Z'` (date/heure actuelle)

2. **Incrementer le num√©ro de version** (ex: 1.0.20 ‚Üí 1.0.21)

3. **Mettre √† jour BUILD_DATE** avec la date/heure actuelle en UTC pour forcer le cache busting

4. **Build et d√©ployer :**
   ```bash
   cd toki-app
   npx expo export --platform web --clear --output-dir web-build
   npx ts-node scripts/verify-build-version.ts web-build
   firebase deploy --only hosting
   ```
   
   **OU utiliser le script automatique (recommand√©) :**
   ```bash
   cd toki-app
   scripts\build-production.bat
   ```

**Pourquoi ?** Le cache busting utilise BUILD_VERSION et BUILD_DATE. Si la version n'est pas mise √† jour, les utilisateurs verront l'ancienne version en cache.

### V√©rification Avant D√©ploiement - R√àGLE CRITIQUE

‚ö†Ô∏è **TOUJOURS v√©rifier avant de d√©ployer**

**Checklist :**
- [ ] Version mise √† jour dans `package.json`, `app.json`, `build-version.ts`
- [ ] `BUILD_DATE` mis √† jour avec date/heure actuelle en UTC
- [ ] Build ex√©cut√© avec `--clear` pour vider le cache Metro Bundler
- [ ] V√©rification que le bundle contient la bonne version (script `verify-build-version.ts`)
- [ ] Hash du bundle a chang√© (indique un nouveau build)

**Script de v√©rification :**
```bash
cd toki-app
npx ts-node scripts/verify-build-version.ts web-build
```

Le script doit afficher `‚úÖ SUCC√àS: Les versions correspondent!` avant de d√©ployer.

**Si la v√©rification √©choue :**
- V√©rifier que `build-version.ts` contient la bonne version
- Rebuild avec `--clear` pour vider le cache Metro
- Utiliser le script `build-production.bat` qui r√©g√©n√®re automatiquement `build-version.ts`

**Importance de `--clear` :**
- Le cache Metro Bundler peut contenir d'anciennes versions de `build-version.ts`
- Toujours utiliser `--clear` lors du build pour garantir un build propre
- Le script `build-production.bat` inclut automatiquement `--clear`

**Script `build-production.bat` :**
- R√©g√©n√®re automatiquement `build-version.ts` avec la version de `package.json`
- Vide le cache Metro avec `--clear`
- V√©rifie que le bundle contient la bonne version
- D√©ploie sur Firebase Hosting

### Variables d'Environnement

- `.env.production` : Cl√©s API (NE JAMAIS commiter)
- Variables Expo : Pr√©fixe `EXPO_PUBLIC_` pour exposition client

---

## üêõ Debugging et Troubleshooting

### Erreurs Hydratation React (#418/#310)

**Cause :** Rendu conditionnel avant hooks OU mismatch SSR/client

**Solution :** √âtat `isClient` avec `useState(false)` + `useEffect(() => setIsClient(true), [])`. Retourner "Chargement..." si `!isClient`, apr√®s TOUS les hooks.

### Console Logs

- En production : Utiliser `logger.debug()` / `logger.info()` (mut√©s)
- Logs critiques : Toujours `logger.warn()` / `logger.error()`
- Logs temporaires : `if (__DEV__) console.log(...)`

---

## ‚úÖ Checklist Avant Commit

- [ ] Tous les hooks d√©clar√©s avant `return` conditionnel
- [ ] `currentUserId` utilis√© correctement pour isolation
- [ ] Sync Firestore appel√©e apr√®s modifications critiques
- [ ] Messages utilisateur en fran√ßais
- [ ] Logs de prod via `logger` (pas `console.log` direct)
- [ ] Pas de cl√©s API/secr√®tes dans le code
- [ ] Types TypeScript corrects (pas de `any` sauf Firebase user)
- [ ] Gestion d'erreurs avec try/catch pour op√©rations async
- [ ] Utilisateurs existants pris en compte
- [ ] Code test√© et fonctionnel

---

## üéì Bonnes Pratiques

### Performance

- Utiliser `useMemo` pour calculs co√ªteux (streaks, stats)
- Utiliser `useCallback` pour callbacks pass√©s en props (√©viter re-renders)
- Limiter re-renders : State local minimal, props stables

### Maintenabilit√©

- Commenter le "pourquoi", pas le "quoi" (code auto-document√©)
- Exporter types depuis `toki-app/lib/types.ts` (pas inline)
- Fonctions pures quand possible (facilitent tests)
- Helpers r√©utilisables dans `toki-app/lib/`

### Tests

- Tests unitaires pour logique m√©tier (`toki-app/lib/stats.ts`, `toki-app/lib/points-*.ts`)
- Tests d'int√©gration pour flows critiques (login, sync)
- Mocker Firebase/AsyncStorage dans tests

### Error Handling

- Op√©rations async : Toujours try/catch
- Sync Firestore : Ne pas bloquer UI si √©chec (logger warning, continuer local)
- Messages d'erreur : Actionnables pour utilisateur (pas de stack traces)

### Versioning

- AsyncStorage keys : Inclure version (ex: `feedtoki_entries_${userId}_v1`)
- Changements breaking : Nouvelle version de key + migration script
- Firestore : Structure document√©e, migrations via scripts

---

## üìù Documentation

- `toki-app/README.md` : Vue d'ensemble, setup, scripts
- `toki-app/GUIDE_DEPLOIEMENT.md` : Instructions d√©ploiement
- `toki-app/CHANGELOG.md` : Historique des changements
- `toki-app/POINTS_SYSTEM_EXPLANATION.md` : Explication syst√®me de points
- `toki-app/MIGRATION_GUIDE.md` : Guide des migrations

---

**Derni√®re mise √† jour :** Janvier 2025  
**Version app :** 1.0.41
